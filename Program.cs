using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

using cc = cclua.lua530;
using lua_State = cclua.lua530.lua_State;
using lua_Debug = cclua.lua530.lua_Debug;

namespace cclua {

    class Program {

        //static string LUA_PROMPT = "> ";
        //static string LUA_PROMPT2 = ">> ";
        static string LUA_PROGNAME = "cclua";
        //static int LUA_MAXINPUT = 512;
        static string LUA_INIT_VAR = "LUA_INIT";
        static string LUA_INITVARVERSION = LUA_INIT_VAR + "_" + cc.LUA_VERSION_MAJOR + "_" + cc.LUA_VERSION_MINOR;


        static lua_State globalL = null;
        static string progname = LUA_PROGNAME;


        /*
        ** Hook set by signal function to stop the interpreter.
        */
        static void lstop (lua_State L, lua_Debug ar) {
            cc.lua_sethook (L, null, 0, 0);  /* reset hook */
            cc.luaL_error (L, "interrupted!");
        }


        /*
        ** Function to be called at a C signal. Because a C signal cannot
        ** just change a Lua state (as there is no proper synchronization),
        ** this function only sets a hook that, when called, will stop the
        ** interpreter.
        */
        static void laction (int i) {
            cc.lua_sethook (globalL, lstop, cc.LUA_MASKCALL | cc.LUA_MASKRET | cc.LUA_MASKCOUNT, 1);
        }


        static void print_usage (string badoption) {
            cc.lua_writestringerror ("{0}: ", progname);
            if (badoption.Length > 1 && (badoption[1] == 'e' || badoption[1] == 'l'))
                cc.lua_writestringerror ("{0}' needs argument\n", badoption);
            else
                cc.lua_writestringerror ("unrecognized option '{0}'\n", badoption);
            cc.lua_writestringerror (
@"usage: {0} [options] [script [args]]
Available options are:
  -e stat  execute string 'stat'  
  -i       enter interactive mode after executing 'script'
  -l name  require library 'name'
  -v       show version information
  -E       ignore environment variables
  --       stop handling options
  -        stop handling options and execute stdin", progname);
        }


        /*
        ** Prints an error message, adding the program name in front of it
        ** (if present)
        */
        static void l_message (string pname, string msg) {
            if (pname != null) cc.lua_writestringerror ("{0}: ", pname);
            cc.lua_writestringerror ("{0}\n", msg);
        }


        /*
        ** Check whether 'status' is not OK and, if so, prints the error
        ** message on the top of the stack. It assumes that the error object
        ** is a string, as it was either generated by Lua or by 'msghandler'.
        */
        static int report (lua_State L, int status) {
            if (status != cc.LUA_OK) {
                string msg = cc.lua_tostring (L, -1);
                l_message (progname, msg);
                cc.lua_pop (L, 1);  /* remove message */
            }
            return status;
        }


        /*
        ** Interface to 'lua_pcall', which sets appropriate message function
        ** and C-signal handler. Used to run all chunks.
        */
        static int docall (lua_State L, int narg, int nres) {
            int nbase = cc.lua_gettop (L) - narg;
            int status = cc.lua_pcall (L, narg, nres, nbase);
            return status;
        }


        static void print_version () {
            cc.lua_writestring (cc.LUA_COPYRIGHT);
            cc.lua_writeline ();
        }


        /*
        ** Create the 'arg' table, which stores all arguments from the
        ** command line ('argv'). It should be aligned so that, at index 0,
        ** it has 'argv[script]', which is the script name. The arguments
        ** to the script (everything after 'script') go to positive indices;
        ** other arguments (before the script name) go to negative indices.
        ** If there is no script name, assume interpreter's name as base.
        */
        static void createargtable (lua_State L, string[] argv, int script) {
            int argc = argv.Length;
            if (script == argc) script = 0;
            int narg = argc - (script + 1);
            cc.lua_createtable (L, narg, script + 1);
            for (int i = 0; i < argc; i++) {
                cc.lua_pushstring (L, argv[i]);
                cc.lua_rawseti (L, -2, i - script);
            }
            cc.lua_setglobal (L, "arg");
        }



        /*
        ** Push on the stack the contents of table 'arg' from 1 to #arg
        */
        static int pushargs (lua_State L) {
            if (cc.lua_getglobal (L, "arg") != cc.LUA_TTABLE)
                cc.luaL_error (L, "'arg' is not a table");
            int n = (int)cc.luaL_len (L, -1);
            cc.luaL_checkstack (L, n + 3, "too many arguments to script");
            int i = 1;
            for (; i <= n; i++)
                cc.lua_rawgeti (L, -i, i);
            cc.lua_remove (L, -i);  /* remove table from the stack */
            return n;
        }


        public static int handle_script (lua_State L, string fname) {
            int status = cc.luaL_loadfile (L, fname);
            if (status == cc.LUA_OK) {
                int n = pushargs (L);  /* push arguments to script */
                status = docall (L, n, cc.LUA_MULTRET);
            }
            return report (L, status);
        }



        /* bits of various argument indicators in 'args' */
        static int has_error = 1;  /* bad option */
        static int has_i = 2;  /* -i */
        static int has_v = 4;  /* -v */
        static int has_e = 8;  /* -e */
        static int has_E = 16;  /* -E */

        /*
        ** Traverses all arguments from 'argv', returning a mask with those
        ** needed before running any Lua code (or an error code if it finds
        ** any invalid argument). 'first' returns the first not-handled argument 
        ** (either the script name or a bad argument in case of error).
        */
        static int collectargs (string[] argv, ref int first) {
            int args = 0;
            int i = 0;
            for (; i < argv.Length; i++) {
                first = i;
                if (argv[i].Length < 1 || argv[i][0] != '-')  /* not an option? */
                    return args;  /* stop handling options */
                else {
                    if (argv[i].Length < 2)
                        return has_error;
                    switch (argv[i][1]) {  /* else check option */
                        case '-': {  /* '--' */
                            if (argv[i].Length > 2)  /* extra characters after '--'? */
                                return has_error;  /* invalid option */
                            first = i + 1;
                            return args;
                        }
                        case '\0': {  /* '-' */
                            return args;  /* script "name" is '-' */
                        }
                        case 'E': {
                            if (argv[i].Length > 2)  /* extra characters after 1st? */
                                return has_error;  /* invalid option */
                            args |= has_E;
                            break;
                        }
                        case 'i' : {
                            args |= has_i;
                            goto case 'v';  /* goes through  (-i implies -v) */
                        }
                        case 'v': {
                            if (argv[i].Length > 2)  /* extra characters after 1st? */
                                return has_error;  /* invalid option */
                            args |= has_v;
                            break;
                        }
                        case 'e': {
                            args |= has_e;
                            goto case 'l';  /* go through */
                        }
                        case 'l': {  /* both options need an argument */
                            if (argv[i].Length == 2) {  /* no concatenated argument? */
                                i++;  /* try next 'argv' */
                                if (i >= argv.Length || argv[i][0] == '-')
                                    return has_error;  /* no next argument or it is another option */
                            }
                            break;
                        }
                        default: return has_error;  /* invalid option */
                    }
                }
            }
            first = i;  /* no script name */
            return args;
        }






        /*
        ** Main body of stand-alone interpreter (to be called in protected mode).
        ** Reads the options and handles them all.
        */
        static int pmain (lua_State L) {
            string[] argv = (string[])cc.lua_touserdata (L, 1);
            int argc = argv.Length;
            int script = 0;
            int args = collectargs (argv, ref script);
            cc.luaL_checkversion (L);  /* check that interpreter has correct version */
            progname = System.Diagnostics.Process.GetCurrentProcess ().ProcessName;
            if (args == has_error) {  /* bad arg? */
                print_usage (argv[script]);  /* 'script' has index of bad arg. */
                return 0;
            }
            if ((args & has_v) != 0)  /* option '-v'? */
                print_version ();
            if ((args & has_E) != 0) {  /* option '-E'? */
                cc.lua_pushboolean (L, 1);  /* signal for libraries to ignore env. vars. */
                cc.lua_setfield (L, cc.LUA_REGISTRYINDEX, "LUA_NOENV");
            }
            cc.luaL_openlibs (L);  /* open standard libraries */
            if (script < argc && handle_script (L, argv[script]) != cc.LUA_OK)  /* execute main script (if there is one) */
                return 0;
            return 1;
        }


        static void Main (string[] args) {
            lua_State L = cc.luaL_newstate ();
            if (L == null) {
                l_message (args[0], "cannot create state: not enough memory");
                return;
            }
            cc.lua_pushcfunction (L, pmain);
            cc.lua_pushlightuserdata (L, args);
            int status = cc.lua_pcall (L, 1, 1, 0);
            int result = cc.lua_toboolean (L, -1);
            report (L, status);
			cc.lua_close(L);
        }
    }
}
